/**
 * Deploy and Register Conditional Coins
 *
 * This script:
 * 1. Builds conditional coin Move modules from packages/conditional_coin/sources/
 *    (modules should be pre-generated by generate-conditional-coins.ts)
 * 2. Deploys the package
 * 3. Registers all TreasuryCaps in the BlankCoinsRegistry
 * 4. Saves deployment info to JSON for use in tests
 *
 * Usage:
 *   npx tsx scripts/deploy-conditional-coins.ts [--registry 0x...existing] [--fee <mist>]
 *
 * Prerequisites:
 *   Run generate-conditional-coins.ts first to generate the Move modules:
 *   npx tsx scripts/generate-conditional-coins.ts <num_outcomes> [asset_decimals] [stable_decimals]
 *
 * Examples:
 *   # Generate and deploy 2-outcome coins (default)
 *   npx tsx scripts/generate-conditional-coins.ts 2
 *   npx tsx scripts/deploy-conditional-coins.ts
 *
 *   # Generate and deploy 4-outcome coins with custom decimals
 *   npx tsx scripts/generate-conditional-coins.ts 4 9 6
 *   npx tsx scripts/deploy-conditional-coins.ts --fee 1000000000
 */

import { Transaction } from "@mysten/sui/transactions";
import { execSync } from "child_process";
import * as fs from "fs";
import * as path from "path";
import { fileURLToPath } from "url";
import { initSDK, executeTransaction, getActiveAddress } from "./execute-tx";

// ESM compatibility for __dirname
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const REPO_ROOT = path.resolve(__dirname, "..", "..");
const CONDITIONAL_COIN_BASE_PATH = path.join(REPO_ROOT, "packages", "conditional_coin");
const DEPLOYMENTS_DIR = path.join(REPO_ROOT, "packages", "deployments");
const SDK_DIR = path.join(REPO_ROOT, "sdk");

interface ConditionalCoinInfo {
  treasuryCapId: string;
  metadataCapId: string;  // MetadataCap<T> object ID (for updating name/description/icon)
  currencyId: string;     // Currency<T> object ID (shared, from coin_registry::finalize)
  coinType: string;
  packageId: string;
  decimals: number;       // Decimals of the coin (9 for asset, 6 for stable)
}

interface ConditionalCoinsDeployment {
  registryId: string;
  coins: Record<string, ConditionalCoinInfo>;
  timestamp: string;
  network: string;
}

/**
 * Information parsed from an existing conditional coin module
 */
interface ParsedCoinModule {
  index: number;
  decimals: number;
  fileName: string;
}

/**
 * Parse an existing conditional coin module to extract its decimals
 * Looks for the pattern: ${decimals}, // decimals
 */
function parseCoinModule(filePath: string): ParsedCoinModule | null {
  const content = fs.readFileSync(filePath, "utf-8");
  const fileName = path.basename(filePath);

  // Extract index from filename (conditional_N.move)
  const indexMatch = fileName.match(/conditional_(\d+)\.move/);
  if (!indexMatch) {
    return null;
  }
  const index = parseInt(indexMatch[1], 10);

  // Extract decimals from module content
  // Pattern: number followed by comma and comment containing "decimals"
  const decimalsMatch = content.match(/(\d+),\s*\/\/.*decimals/i);
  if (!decimalsMatch) {
    console.warn(`Could not find decimals in ${fileName}, defaulting to 9`);
    return { index, decimals: 9, fileName };
  }

  return {
    index,
    decimals: parseInt(decimalsMatch[1], 10),
    fileName,
  };
}

/**
 * Scan the sources directory for existing conditional coin modules
 * Returns sorted list of parsed modules
 */
function scanExistingModules(): ParsedCoinModule[] {
  const sourcesDir = path.join(CONDITIONAL_COIN_BASE_PATH, "sources");

  if (!fs.existsSync(sourcesDir)) {
    throw new Error(`Sources directory not found: ${sourcesDir}\nRun generate-conditional-coins.ts first.`);
  }

  const files = fs.readdirSync(sourcesDir);
  const modules: ParsedCoinModule[] = [];

  for (const file of files) {
    if (file.startsWith("conditional_") && file.endsWith(".move")) {
      const parsed = parseCoinModule(path.join(sourcesDir, file));
      if (parsed) {
        modules.push(parsed);
      }
    }
  }

  if (modules.length === 0) {
    throw new Error(
      `No conditional coin modules found in ${sourcesDir}\nRun generate-conditional-coins.ts first.`
    );
  }

  // Sort by index
  modules.sort((a, b) => a.index - b.index);

  return modules;
}

async function main() {
  const args = process.argv.slice(2);
  let existingRegistryId: string | null = null;
  let feeOverride: bigint | null = null;

  for (let i = 0; i < args.length; i += 1) {
    const arg = args[i];
    if (arg === "--registry") {
      const value = args[i + 1];
      if (!value) {
        throw new Error("--registry flag requires an object ID");
      }
      existingRegistryId = value;
      i += 1;
    } else if (arg === "--fee") {
      const value = args[i + 1];
      if (!value) {
        throw new Error("--fee flag requires a number (mist)");
      }
      feeOverride = BigInt(value);
      i += 1;
    } else if (arg === "--decimals") {
      // Legacy flag - ignore for backward compatibility
      console.warn("Warning: --decimals flag is deprecated. Decimals are read from generated modules.");
      i += 1; // Skip the value
    } else {
      throw new Error(`Unknown argument: ${arg}`);
    }
  }

  console.log("=".repeat(80));
  console.log("DEPLOY AND REGISTER CONDITIONAL COINS");
  console.log("=".repeat(80));
  console.log();

  // Scan existing modules (generated by generate-conditional-coins.ts)
  console.log("üìÇ Scanning for pre-generated conditional coin modules...");
  const existingModules = scanExistingModules();
  const coinCount = existingModules.length;

  // Initialize SDK
  const sdk = await initSDK();
  const activeAddress = getActiveAddress();
  console.log(`Active address: ${activeAddress}`);
  console.log(`Found ${coinCount} conditional coin modules:`);
  for (const mod of existingModules) {
    console.log(`  - ${mod.fileName} (${mod.decimals} decimals)`);
  }
  console.log();

  // Get one_shot_utils package
  const oneShotUtils = sdk.deployments.getPackage("futarchy_one_shot_utils");
  if (!oneShotUtils) {
    console.error("‚ùå futarchy_one_shot_utils not found in deployments!");
    process.exit(1);
  }

  // Create BlankCoinsRegistry if it doesn't exist
  let registryId = existingRegistryId;
  if (!registryId) {
    console.log("üìù Creating BlankCoinsRegistry...");
    const createRegistryTx = new Transaction();

    const registry = createRegistryTx.moveCall({
      target: `${oneShotUtils.packageId}::blank_coins::create_registry`,
      arguments: [],
    });

    createRegistryTx.moveCall({
      target: `${oneShotUtils.packageId}::blank_coins::share_registry`,
      arguments: [registry],
    });

    const registryResult = await executeTransaction(sdk, createRegistryTx, {
      network: "devnet",
      showObjectChanges: true,
    });

    // Find the shared BlankCoinsRegistry object
    const registryObject = registryResult.objectChanges?.find(
      (obj: any) =>
        obj.type === "created" &&
        obj.objectType &&
        obj.objectType.includes("::blank_coins::BlankCoinsRegistry")
    );

    if (!registryObject) {
      console.error("‚ùå Failed to find BlankCoinsRegistry in object changes!");
      console.error("Object changes:", JSON.stringify(registryResult.objectChanges, null, 2));
      process.exit(1);
    }

    registryId = (registryObject as any).objectId;
    console.log(`‚úÖ BlankCoinsRegistry created: ${registryId}`);
    console.log();
  } else {
    console.log(`‚ÑπÔ∏è  Using existing BlankCoinsRegistry: ${registryId}`);
    console.log();
  }

  if (!registryId) {
    throw new Error("CoinRegistry ID not available");
  }

  // Modules are already generated by generate-conditional-coins.ts
  // Just build and deploy
  console.log("üì¶ Building and deploying conditional_coin package...");
  console.log();

  const buildCmd = `cd ${CONDITIONAL_COIN_BASE_PATH} && sui move build --silence-warnings`;
  execSync(buildCmd, { stdio: "inherit" });

  const publishCmd = `cd ${CONDITIONAL_COIN_BASE_PATH} && sui client publish --gas-budget 100000000 --json`;
  const publishOutput = execSync(publishCmd, { encoding: "utf-8" });
  const publishResult = JSON.parse(publishOutput);

  if (publishResult.effects?.status?.status !== "success") {
    console.error("‚ùå Deployment failed!");
    console.error(publishResult);
    process.exit(1);
  }

  // Extract package ID
  const packageId = publishResult.objectChanges?.find(
    (obj: any) => obj.type === "published"
  )?.packageId;

  if (!packageId) {
    console.error("‚ùå Failed to extract package ID!");
    process.exit(1);
  }

  console.log(`‚úÖ Deployed: ${packageId}`);
  console.log();

  // After publishing OTW coins, the Currency objects are transferred to CoinRegistry (0xc)
  // They need to be promoted to shared objects via finalize_registration
  // First, extract the Currency object IDs from the publish result
  const objectChanges = publishResult.objectChanges || [];

  // Collect Currency objects that need finalization
  // After OTW publish with finalize(), Currency is owned by CoinRegistry (0xc)
  // We need to call finalize_registration to promote them to shared objects
  const currenciesToFinalize: Array<{
    currencyId: string;
    version: string;
    digest: string;
    coinType: string;
    moduleName: string;
  }> = [];

  for (const mod of existingModules) {
    const moduleName = `conditional_${mod.index}`;
    // Find Currency<T> objects created during init (they're owned by 0xc after finalize)
    const currency = objectChanges.find(
      (obj: any) =>
        obj.objectType?.includes(`::${moduleName}::`) && obj.objectType?.includes("Currency<")
    );
    if (currency) {
      // Extract coin type from Currency<CoinType>
      const coinTypeMatch = currency.objectType.match(/Currency<(.+)>/);
      currenciesToFinalize.push({
        currencyId: currency.objectId,
        version: currency.version,
        digest: currency.digest,
        coinType: coinTypeMatch?.[1] || "",
        moduleName,
      });
    }
  }

  // Call finalize_registration on CoinRegistry to promote Currency objects to shared
  if (currenciesToFinalize.length > 0) {
    console.log("üìù Calling finalize_registration on CoinRegistry for Currency objects...");

    const finalizeTx = new Transaction();
    const coinRegistryId = "0x000000000000000000000000000000000000000000000000000000000000000c";

    for (const { currencyId, version, digest, coinType, moduleName } of currenciesToFinalize) {
      console.log(`   Finalizing ${moduleName}: ${currencyId} (v${version})`);
      finalizeTx.moveCall({
        target: `0x2::coin_registry::finalize_registration`,
        typeArguments: [coinType],
        arguments: [
          finalizeTx.object(coinRegistryId), // CoinRegistry (shared at 0xc)
          finalizeTx.receivingRef({
            objectId: currencyId,
            version,
            digest,
          }),
        ],
      });
    }

    try {
      const finalizeResult = await executeTransaction(sdk, finalizeTx, {
        network: "devnet",
        showObjectChanges: true,
      });
      console.log("‚úÖ All Currency objects finalized and shared!");

      // Update currenciesToFinalize with the NEW Currency IDs from finalize_registration
      // The old Currency objects are deleted/wrapped, new shared ones are created
      const finalizeChanges = finalizeResult.objectChanges || [];
      for (const item of currenciesToFinalize) {
        // Find the new shared Currency object for this coin type
        const newCurrency = finalizeChanges.find(
          (obj: any) =>
            obj.type === "created" &&
            obj.objectType?.includes("Currency<") &&
            obj.objectType?.includes(item.coinType)
        );
        if (newCurrency) {
          console.log(`   Updated ${item.moduleName}: ${item.currencyId} ‚Üí ${newCurrency.objectId} (shared)`);
          item.currencyId = newCurrency.objectId;
        }
      }
      console.log();
    } catch (error) {
      console.error("‚ùå Failed to finalize Currency objects:", error);
      console.error("   Continuing anyway - Currency objects may not be shared properly");
      console.log();
    }
  }

  // Extract TreasuryCaps, MetadataCaps, and Currency objects
  // Use the updated currencyIds from finalize_registration if available
  const currencyIdMap = new Map(currenciesToFinalize.map(c => [c.moduleName, c.currencyId]));
  const coins: Record<string, ConditionalCoinInfo> = {};

  for (const mod of existingModules) {
    const moduleName = `conditional_${mod.index}`;
    const decimals = mod.decimals;

    const treasuryCap = objectChanges.find(
      (obj: any) =>
        obj.objectType?.includes(`::${moduleName}::`) && obj.objectType?.includes("TreasuryCap")
    );
    // Find MetadataCap<T> (from coin_registry::finalize)
    const metadataCap = objectChanges.find(
      (obj: any) =>
        obj.objectType?.includes(`::${moduleName}::`) && obj.objectType?.includes("MetadataCap<")
    );
    // Find the shared Currency<T> object (created by coin_registry::finalize)
    const currency = objectChanges.find(
      (obj: any) =>
        obj.objectType?.includes(`::${moduleName}::`) && obj.objectType?.includes("Currency<")
    );

    if (!treasuryCap) {
      console.error(`‚ùå Failed to find TreasuryCap for ${moduleName}`);
      process.exit(1);
    }

    if (!metadataCap) {
      console.error(`‚ùå Failed to find MetadataCap for ${moduleName}`);
      process.exit(1);
    }

    if (!currency) {
      console.error(`‚ùå Failed to find Currency<T> for ${moduleName}`);
      process.exit(1);
    }

    // Use the updated currency ID from finalize_registration if available
    // (the original currency from publish is deleted, new shared one is created)
    const finalCurrencyId = currencyIdMap.get(moduleName) || currency.objectId;

    coins[moduleName] = {
      treasuryCapId: treasuryCap.objectId,
      metadataCapId: metadataCap.objectId,
      currencyId: finalCurrencyId,
      coinType: treasuryCap.objectType.match(/TreasuryCap<(.+)>/)?.[1] || "",
      packageId,
      decimals,
    };

    console.log(`‚úÖ ${moduleName} (${decimals} decimals):`);
    console.log(`   TreasuryCap: ${coins[moduleName].treasuryCapId}`);
    console.log(`   MetadataCap: ${coins[moduleName].metadataCapId}`);
    console.log(`   Currency: ${coins[moduleName].currencyId}`);
    console.log(`   Type: ${coins[moduleName].coinType}`);
  }
  console.log();

  // Register all caps in BlankCoinsRegistry
  // BUCKETED BY DECIMALS: Each coin is deposited with its expected_decimals
  // which is validated against Currency<T>.decimals()
  console.log("üìù Registering conditional coins in BlankCoinsRegistry...");
  console.log();

  const registerTx = new Transaction();
  const fee = feeOverride ?? 0n; // Default zero fee for test coins

  for (const [coinName, info] of Object.entries(coins)) {
    console.log(`   Registering ${coinName} (${info.decimals} decimals)...`);

    registerTx.moveCall({
      target: `${oneShotUtils.packageId}::blank_coins::deposit_coin_set_entry`,
      typeArguments: [info.coinType],
      arguments: [
        registerTx.object(registryId),
        registerTx.object(info.currencyId), // Currency<T> for validation
        registerTx.object(info.treasuryCapId),
        registerTx.object(info.metadataCapId), // MetadataCap<T> for updating metadata later
        registerTx.pure.u8(info.decimals), // expected_decimals (validated against Currency<T>)
        registerTx.pure.u64(fee),
        registerTx.sharedObjectRef({
          objectId: "0x6",
          initialSharedVersion: 1,
          mutable: false,
        }),
      ],
    });
  }

  await executeTransaction(sdk, registerTx, {
    network: "devnet",
  });

  console.log("‚úÖ All conditional coins registered in BlankCoinsRegistry!");
  console.log();

  // Save deployment info grouped by decimals
  // Format: { registryId, packageId, byDecimals: { 9: [...], 6: [...] }, coins: {...} }
  const deploymentInfo: Record<string, any> = {
    packageId,
    registryId,
    coinCount,
    byDecimals: {} as Record<number, ConditionalCoinInfo[]>,
    coins, // All coins keyed by module name (conditional_0, conditional_1, etc.)
  };

  // Group coins by decimals for easy lookup
  for (const [coinName, info] of Object.entries(coins)) {
    if (!deploymentInfo.byDecimals[info.decimals]) {
      deploymentInfo.byDecimals[info.decimals] = [];
    }
    deploymentInfo.byDecimals[info.decimals].push(info);
  }

  // Also add outcome-indexed format for extractConditionalOutcomes():
  // cond{outcomeIndex}_{asset|stable} -> coin info
  // Pattern: conditional_0 ‚Üí cond0_asset, conditional_1 ‚Üí cond0_stable,
  //          conditional_2 ‚Üí cond1_asset, conditional_3 ‚Üí cond1_stable, etc.
  for (const [coinName, info] of Object.entries(coins)) {
    const match = coinName.match(/^conditional_(\d+)$/);
    if (match) {
      const moduleIndex = parseInt(match[1], 10);
      const outcomeIndex = Math.floor(moduleIndex / 2);
      const coinType = moduleIndex % 2 === 0 ? "asset" : "stable";
      const key = `cond${outcomeIndex}_${coinType}`;
      deploymentInfo[key] = info;
    }
  }

  deploymentInfo.timestamp = new Date().toISOString();
  deploymentInfo.network = "devnet";

  // Save to deployments directory
  const deploymentFile = path.join(DEPLOYMENTS_DIR, "conditional_coins.json");
  fs.writeFileSync(deploymentFile, JSON.stringify(deploymentInfo, null, 2));
  console.log(`‚úÖ Saved deployment info: ${deploymentFile}`);

  // Save to SDK directory for easy access
  const sdkFile = path.join(SDK_DIR, "conditional-coins-info.json");
  fs.writeFileSync(sdkFile, JSON.stringify(deploymentInfo, null, 2));
  console.log(`‚úÖ Saved to SDK: ${sdkFile}`);
  console.log();

  // Process deployments to update SDK
  console.log("üîÑ Processing deployments to update SDK...");
  execSync(`cd ${SDK_DIR} && npx tsx scripts/process-deployments.ts`, { stdio: "inherit" });
  console.log();

  console.log("=".repeat(80));
  console.log("‚úÖ CONDITIONAL COINS DEPLOYED AND REGISTERED!");
  console.log("=".repeat(80));
  console.log();
  console.log("Summary:");
  console.log(`  - ${coinCount} conditional coins deployed and registered in BlankCoinsRegistry`);
  // Group by decimals for summary
  const decimalsCount: Record<number, number> = {};
  for (const mod of existingModules) {
    decimalsCount[mod.decimals] = (decimalsCount[mod.decimals] || 0) + 1;
  }
  for (const [decimals, count] of Object.entries(decimalsCount)) {
    console.log(`    - ${count} coins with ${decimals} decimals`);
  }
  console.log();
  console.log("Next steps:");
  console.log("  1. Conditional coins are now in BlankCoinsRegistry");
  console.log("  2. Proposal creation can fetch them via take_coin_set(registry, decimals, capId, ...)");
  console.log("  3. Use 9 decimals for asset-conditional coins");
  console.log("  4. Use 6 decimals for stable-conditional coins");
  console.log();
}

main().catch((error) => {
  console.error("‚ùå Error:", error);
  process.exit(1);
});
